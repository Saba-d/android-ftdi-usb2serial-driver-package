#summary Code analysis of libftdi
#labels Phase-Design

=Functions in libusb that are used by libftdi=

==usb_control_msg: ==

Send a control message to a device. The interface definition is:
int usb_control_msg(usb_dev_handle * dev, int requesttype, int request, int value, int index, char * bytes, int size, int timeout);

This is a function used to send usb control info to the device. This function is used widely in Libftdi to modifiy the configuration of the chip and port. Functions that use usb_control_msg includes:
	* ftdi_usb_reset
	* ftdi_usb_purge_rx_buffer
	* ftdi_usb_purge_tx_buffer
	* ftdi_set_baudrate
	* ftdi_set_line_property2
	* ftdi_enable_bitbang
	* ftdi_disable_bitbang
	* ftdi_set_bitmode
	* ftdi_read_pins
	* ftdi_set_latency_timer
	* ftdi_get_latency_timer
	* ftdi_poll_modem_status
	* ftdi_setflowctrl
	* ftdi_setdtr
	* ftdi_setrts
	* ftdi_setdtr_rts
	* ftdi_set_event_char
	* ftdi_set_error_char
	* ftdi_read_eeprom_location
	* ftdi_read_eeprom
	* ftdi_read_chipid
	* ftdi_read_eeprom_getsize
	* ftdi_write_eeprom_location
	* ftdi_write_eeprom
	* ftdi_erase_eeprom
	
==usb_bulk_read:==
Read data from a bulk endpoint. The interface definition is 
int usb_bulk_read(usb_dev_handle * dev, int ep, char * bytes, int size, int timeout);
The function is ONLY used to read bulk data from usb endpoint. So there's only one function calls it:
	* ftdi_read_data
	
==usb_bulk_write:==
Write data to a bulk endpoint. The interface definition is:
int usb_bulk_write(usb_dev_handle * dev, int ep, char * bytes, int size, int timeout);
The function is ONLY used to write bulk data to usb endpoint. So there's only one function calls it:
	* ftdi_write_data
	
==usb_open:==
Opens a USB device.
usb_dev_handle * usb_open(struct * usb_device dev);
This function is used in following Libftdi functions:
	* ftdi_usb_open_dev
	* ftdi_usb_open_desc_index
	* ftdi_usb_get_strings

==usb_close:==
Closes a USB device
int usb_close(usb_dev_handle * dev);
This function is ONLY used in following Libftdi function:
	* ftdi_usb_close_internal
	
==usb_init:==
Initialize libusb
void usb_init(void);
This function is used in following libftdi functions:
	* ftdi_usb_find_all
	* ftdi_usb_open_desc_index
	* ftdi_usb_open_string

==usb_find_busses:==
Finds all USB busses on system
int usb_find_busses(void);
The function is used in following libftdi functions:
	* ftdi_usb_find_all
	* ftdi_usb_open_desc
	* ftdi_usb_open_desc_index
	* ftdi_usb_open_string
	* ftdi_usb_find_all
	
==usb_find_devices:==
Find all devices on all USB devices
This function is used in following libftdi functions:
int usb_find_devices(void);
	* ftdi_usb_find_all
	* ftdi_usb_open_desc_index
	* ftdi_usb_open_string

==usb_get_busses==
Return the list of USB busses found
struct usb_bus * usb_get_busses(void);
This function is used in following libftdi functions:
	* ftdi_usb_find_all
	* ftdi_usb_open_desc_index
	* ftdi_usb_open_string

==usb_strerror==

==usb_get_string_simple==
Retrieves a string descriptor from a device using the first language
int usb_get_string_simple(usb_dev_handle * dev, int index, char * buf, size_t buflen);
This function is used in following libftdi functions:
	* ftdi_usb_get_strings
	* ftdi_usb_open_desc_index

==usb_detach_kernel_driver_np==
Detach kernel driver from interface
int usb_detach_kernel_driver_np(usb_dev_handle * dev, int interface);
This function is used in following libftdi functions:
	* ftdi_usb_open_dev

==usb_set_configuration==
Sets the active configuration of a device
int usb_set_configuration(usb_dev_handle * dev, int configuration);
This function is used in following libftdi functions:
	* ftdi_usb_open_dev

==usb_claim_interface==
Claim an interface of a device
int usb_claim_interface(usb_dev_handle * dev, int interface);
This function is used in following libftdi functions:
	* ftdi_usb_open_dev

==usb_release_interface==
Releases a previously claimed interface
int usb_release_interface(usb_dev_handle * dev, int interface);
This function is used in following libftdi functions:
	* ftdi_usb_close

=Importance of the above functions=
Below functions are those we must have, in order to perform the FTDI device operation,
So we have to find what Android functions exactly implements these functionalities.:
	* usb_control_msg
	* usb_bulk_read
	* usb_bulk_write
	* usb_open
	* usb_close
	* usb_claim_interface: used to claim more than one interface on a device. We have to find functions that does the same thing in Android.
	* usb_release_interface: similar to above reason.
	* usb_set_configuration: This function sets the USB port configuration, such as support 100mA, or more. Android may have something similar to this.

Below functions are for USB infromation retrieving, Doesn't matter if Android provides exactly the same thing. We can always use what Android provides.
	* usb_find_busses
	* usb_find_devices
	* usb_get_busses
	* usb_get_string_simple

usb_init is only for libusb internal use only. we don't need it at all.

And these functions needs further look into:
	* usb_detach_kernel_driver_np: This function will detach a kernel driver from the interface specified by parameter interface. usually used before opening a device. We don't need it cause android will handle these things.
	
	
=What Android functions could be used=
Below are the corrisponding Android equivalent of the above must-have libusb functions. Note that Android put everything in java classes. So the actual usage of these functions shall follow the objective-oriented style of coding, no need to be too ridgid to C-style.
==usb_control_msg:==
This libusb function can be replaced by Android function:

public class UsbDeviceConnection

public int controlTransfer (int requestType, int request, int value, int index, byte[] buffer, int length, int timeout) 

==usb_bulk_read and usb_bulk_write==
Both of these two functions can be replaced by Android function:

public class UsbDeviceConnection

public int bulkTransfer (UsbEndpoint endpoint, byte[] buffer, int length, int timeout) 

==usb_open:==
This libusb function can be replaced by Android function:

public class UsbManager

public UsbDeviceConnection openDevice (UsbDevice device) 



==usb_close:==
This libusb function can be replaced by Android function:

public class UsbDeviceConnection

public void close () 

Note that Android's USB device open and close are implemented in different classes, which makes sense. The UsbManager class opens the device. The UsbDeviceConnection class closes itself.

==usb_claim_interface==
This libusb function can be replaced by Android function:

public class UsbDeviceConnection

public boolean claimInterface (UsbInterface intf, boolean force) 

==usb_release_interface==
This libusb function can be replaced by Android function:

public class UsbDeviceConnection

public boolean releaseInterface (UsbInterface intf) 

==usb_set_configuration==

Don't know yet if Android has such capabilities or not...



=Data structures used in libFTDI that is from Libusb=

==usb_config_descriptor==

==usb_interface==

==usb_interface_descriptor==

==usb_bus==

==usb_device==

=How the usb_control_msg set DTR, RTS or other stuff for each individual channels on a FTDI chip?=
Since usb_control_msg is only for "control message", or say it transmitt only on usb endpoint 0. 
Then the question rises: How by calling such a function can set individual channel's DTR, RTS and other stuff??

The answer turns out to be as following:

The usb_control_msg function has following prototype:

int usb_control_msg(usb_dev_handle *dev, int requesttype, int request, int value, int index, char *bytes, int size, int timeout);

The first parameter is definitely the device context pointer.

The second is requesttype, for FTDI chip control, it's usually FTDI_DEVICE_OUT_REQTYPE

The third parameter is the request itself, or the command that directs FTDI chip what to do. e.g. for setDTR, the request is defined in ftdi.h as: SIO_SET_MODEM_CTRL_REQUEST

The fourth parameter is the parameter to the request. e.g. for setDTR, the request is SIO_SET_MODEM_CTRL_REQUEST, the value is SIO_SET_DTR_HIGH or SIO_SET_DTR_LOW in order to set DTR to high or low.

The fifth parameter is the KEY POINT here, the index is corrisponding to WHICH FTDI CHIP CHANNEL YOU WANT TO SEND THE USB CONTROL MESSAGE TO.
so this is how the control message is differentiated by different channels.